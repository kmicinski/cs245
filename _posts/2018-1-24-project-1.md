---
layout: project
title:  "Project 1I: Basic Stack Smashing and Assembly"
date:   2018-1-24
due: 2018-2-13
categories: project assignment
permalink: /project/1
---

This project will have you (and eventually your groupmates) create a
variety of exploits and defend against those exploits. This portion of
the lab is individual work, and will count for 60% of your grade.

- **Handed out: first week of class**
- **Due: Wednesday of 3rd week (midnight)**

### Part 1: Stack-based Buffer Overflows

In this part of the project, you will exploit a stack-based buffer
overflow vulnerability in a variety of ways.

In your project folder, you will find a file `vuln.c`. This program
contains a vulnerable function `foo`:

```
void foo(char *input) {
  char buffer[100];

  // Copy `input` into the buffer
  strcpy(buffer, input);
  
  printf("Successfully copied the input!\n");
}
```

The program calls `foo` with the program's first command line
argument.

**Compiling the program**

First, you'll have to compile the program. To do this, you can just
use the standard compiler `gcc`. You can do so like this:

    gcc vuln.c -o vuln

`gcc` will then produce an output file `vuln` that contains the
program. However, there is a slight problem with this approach: the
standard compiler will actually recognize when a program is
potentially vulnerable to buffer overflow attacks.

### Task 1a: Drawing the stack

**Deliverable:** Draw `foo`'s stack right before the call to
`strcpy`. You can do this on a piece of paper or in digitized
form. Whatever you do, digitize it (either by taking a picture with
your phone, scanner, etc..) and submit it as
`stack-before-strcpy.<png/jpg>`.

**Bonus points:** You will get +1 bonus points if you can generate
this image using `gdb`. However, you must make gdb print out enough of
the stack to show the saved base pointer and return address.

### Task 1b: Generate a payload and crash the program

This program is susceptible to a buffer overflow attack. Your first
task is to figure out how to merely crash the program. Because the
program copies its first command-line argument, you will do that by
extending `crash_vuln.sh` to actually crash the program.

    ./vuln "Hello, world!"

**Deliverable:** `crash_vuln.sh`, which--when executed--crashes the
program `vuln`.

*Note:* It is okay if your program crashes after printing "Hello,
world!" for this part.

#### A Note on Writing Exploits

One common scenario when writing exploit payloads is that we find
ourselves writing some number of uninteresting bytes followed by the
"real" code. This is because--to exploit a buffer overflow--we have to
fill up the whole buffer. In these scenarios, it's common to use a
script to construct the payload. For example, you could write a script
in Python to insert 25 `A`s before the ultimate bytes `0x23, 0x42 0x43
0x22` (which might be the address you want to inject, etc..).

    print "A"*25+"\x23\x42\x43"



### Task 1c: "Hello, World!"

Next, you need to make the program print "Hello, world!". But you
can't just run it with the input "Hello, world!". There's program
contains a function, `helloWorld`, which will print `Hello, World!` to
the screen. To make the computer execute that function, you'll need to 

To call `helloWorld`, you'll need to design a payload overwrites the
buffer in `foo` and then retargets execution to point at `helloWorld`
in memory.

- First, you have to find `helloWorld` in memory. To do that, run GDB
and use the `info address` command (which you can read about
[here](http://visualgdb.com/gdbreference/commands/info_address)).

- Next, you need to construct a payload that will overwrite the return
  address of `foo` to insted return to `helloWorld`.

One good way to do this is by using GDB to manually figure out how to
redirect control flow at first. This helps you get a feel for where
things should be in memory, and you can draw them out on a whiteboard
or on paper as you use GDB. It also helps you debug your exploit as
you develop it.

For example, here's one run of the program where I tell GDB to show me
what the contents of memory are around the current stack pointer
(which I got via `info register esp`). 

The first thing I do is to ask where the current saved RIP is stored:

```
(gdb) info frame
Stack level 0, frame at 0x7fff5fbff4e0:
 rip = 0x100000e04 in foo; saved rip = 0x1500e0000
 called by frame at 0x7fff5fbff4e8
 Arglist at 0x7fff5fbff4d0, args:
 Locals at 0x7fff5fbff4d0, Previous frame's sp is 0x7fff5fbff4e0
 Saved registers:
  rbp at 0x7fff5fbff4d0, rip at 0x7fff5fbff4d8
```

It tells us that the saved RIP is at `0x1500e0000`. This is the
address we want to overwrite. Let's find out where `helloWorld` is
located:

```
(gdb) info address helloWorld
Symbol "helloWorld" is at 0x100000e50 in a file compiled without debugging.
```

So we need to set the RIP to point to that address:

```
(gdb) set *(0x7fff5fbff4dc) = 0x1
(gdb) set *(0x7fff5fbff4d8) = 0x0000e50
```

Pay careful attention to how I did that. GDB will let me set whole
integers (which are four bytes) at a time. The base of the integer is
at `0x7fff5fbff4d8`, and four bytes up is `0x7fff5fbff4dc` (remember,
the stack grows **down**!).

Now, let's check that I got it right (I didn't the first few times I
did this..):

```
(gdb) info frame
Stack level 0, frame at 0x7fff5fbff4e0:
 rip = 0x100000e04 in foo; saved rip = 0x100000e50
 called by frame at 0x7fff5fbff510
 Arglist at 0x7fff5fbff4d0, args:
 Locals at 0x7fff5fbff4d0, Previous frame's sp is 0x7fff5fbff4e0
 Saved registers:
  rbp at 0x7fff5fbff4d0, rip at 0x7fff5fbff4d8
(gdb) info address helloWorld
Symbol "helloWorld" is at 0x100000e50 in a file compiled without debugging.
```

Finally, let's run it:

```
(gdb) continue
Continuing.
Successfully copied the input!
Hello, world!```
<Segfault>
```

Now, your job is to careate a payload that does this!

**Deliverable: hello_world.sh, which will print "Hello, World!" when
run."**

### Part 2: Basic Assembly, System Calls, and Shellcode

Let's say that we wanted to avoid having our program crash after we
ran our exploit. This is actually a bit nontrivial: after calling into
`helloWorld`, the program will set the return address at whatever the
next instruction was from within `foo`. Instead, we're going to write
our *own* assembly, and inject that in as a payload.

For this part of the lab, I have provided a starter file,
`hello.S`. You have three tasks to complete.

#### Task: Implement `callHelloDave`

The lab starter files include a function, `hello`, which will print
its argument using the built-in library function `printf`. Your job is
to figure out how to call it 

### Task: Implement a variant of `foo` in assembly

Here you are going to write some assembly code that basically
corresponds to this:

```
void foo(char *input) {
    helloWorld();
    return;
}
```

You will do this by extending `foo_example.S`. Currently this code
will crash when you try to run it: 

### Part 3: Combining This to Build an Exploit



### List of all deliverables for Lab 1I

- Part 1a (5 points + 1 possible) `stack-before-strcpy.<png/jpg>`
- Part 1b (5 points) `crash_vuln.sh` (5 points)
- Part 1c (15 points) `hello_world.sh`

### Task 4 (10 points): "Hello, Dave!"



## Resources
http://www.vividmachines.com/shellcode/shellcode.html
